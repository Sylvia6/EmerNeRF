# Software License Agreement (BSD License)
#
# Copyright (c) 2008, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""
Support library for Python autogenerated message files.

This defines the Message base class used by genpy as well as support
libraries for type checking and retrieving message classes by type name.
"""

import codecs
import itertools
import math
import struct
import sys

import yaml

from .rostime import Duration
from .rostime import TVal
from .rostime import Time

if sys.version > '3':
    long = int

try:
    import numpy as np
    _valid_float_types = [float, int, long, np.float32, np.float64, np.int8, np.int16, np.int32, np.int64, np.uint8,
                          np.uint16, np.uint32, np.uint64]
except ImportError:
    _valid_float_types = [float, int, long]

# common struct pattern singletons for msgs to use. Although this
# would better placed in a generator-specific module, we don't want to
# add another import to messages (which incurs higher import cost)
struct_I = struct.Struct('<I')

_warned_decoding_error = set()

# Notify the user while not crashing in the face of errors attempting
# to decode non-unicode data within a ROS message.
class RosMsgUnicodeErrors:
    def __init__(self):
        self.msg_type = None

    def __call__(self, err):
        global _warned_decoding_error
        if self.msg_type not in _warned_decoding_error:
            _warned_decoding_error.add(self.msg_type)
            # Lazy import to avoid this cost in the non-error case.
            import logging
            logger = logging.getLogger('rosout')
            extra = "message %s" % self.msg_type if self.msg_type else "unknown message"
            logger.error("Characters replaced when decoding %s (will print only once): %s", extra, err)
        return codecs.replace_errors(err)
codecs.register_error('rosmsg', RosMsgUnicodeErrors())


def isstring(s):
    """Small helper version to check an object is a string in a way that works for both Python 2 and 3."""
    try:
        return isinstance(s, basestring)
    except NameError:
        return isinstance(s, str)


class MessageException(Exception):
    """Base exception type for errors in genmsg routines."""

    pass


class DeserializationError(MessageException):
    """Message deserialization error."""

    pass


class SerializationError(MessageException):
    """Message serialization error."""

    pass


# we expose the generic message-strify routine for fn-oriented code like rostopic

def strify_message(val, indent='', time_offset=None, current_time=None, field_filter=None, fixed_numeric_width=None):
    """
    Convert value to string representation.

    :param val: to convert to string representation. Most likely a Message.  ``Value``
    :param indent: indentation. If indent is set, then the return value will have a leading newline character, ``str``
    :param time_offset: if not None, time fields will be displayed
      as deltas from  time_offset, ``Time``

    :param current_time: currently not used. Only provided for API
      compatibility. current_time passes in the current time with
      respect to the message, ``Time``
    :param field_filter: filter the fields that are strified for Messages, ``fn(Message)->iter(str)``
    :returns: string (YAML) representation of message, ``str``
    """
    type_ = type(val)
    if type_ in (int, long, float) and fixed_numeric_width is not None:
        if type_ is float:
            num_str = ('%.' + str(fixed_numeric_width) + 'f') % val
            return num_str[:max(num_str.find('.'), fixed_numeric_width)]
        else:
            return ('%' + str(fixed_numeric_width) + 'd') % val
    elif type_ in (int, long, float, bool):
        return str(val)
    elif isstring(val):
        if not val:
            return "''"
        # escape strings for use in yaml file using yaml dump with default style to avoid trailing "...\n"
        return yaml.dump(val, default_style='"').rstrip('\n')
    elif isinstance(val, TVal):

        if time_offset is not None and isinstance(val, Time):
            val = val-time_offset

        if fixed_numeric_width is not None:
            format_str = '%' + str(fixed_numeric_width) + 'd'
            sec_str = '\n%ssecs: ' % indent + (format_str % val.secs)
            nsec_str = '\n%snsecs: ' % indent + (format_str % val.nsecs)
            return sec_str + nsec_str
        else:
            return '\n%ssecs: %s\n%snsecs: %9d' % (indent, val.secs, indent, val.nsecs)

    elif type_ in (list, tuple):
        if len(val) == 0:
            return '[]'
        val0 = val[0]
        if type(val0) in (int, float) and fixed_numeric_width is not None:
            list_str = '[' + ''.join(strify_message(v, indent, time_offset, current_time, field_filter, fixed_numeric_width) + ', ' for v in val).rstrip(', ') + ']'
            return list_str
        elif isstring(val0):
            # escape list of strings for use in yaml file using yaml dump
            yaml_str = yaml.dump(val).rstrip('\n')
            # earlier versions of PyYAML return: ['', '']\n
            # newer versions of PyYaml return: - ''\n- ''\n
            assert yaml_str[0] in ('[', '-')
            if yaml_str[0] == '[':
                return yaml_str
            return '\n' + '\n'.join(indent + line for line in yaml_str.splitlines())
        elif type(val0) in (int, float, bool):
            return str(list(val))
        else:
            pref = indent + '- '
            indent = indent + '  '
            return '\n'+'\n'.join([pref+strify_message(v, indent, time_offset, current_time, field_filter, fixed_numeric_width) for v in val])
    elif isinstance(val, Message):
        # allow caller to select which fields of message are strified
        if field_filter is not None:
            fields = list(field_filter(val))
        else:
            fields = val.__slots__

        p = '%s%%s: %%s' % (indent)
        ni = '  '+indent
        if sys.hexversion > 0x03000000:  # Python3
            vals = '\n'.join([
                p % (f, strify_message(_convert_getattr(val, f, t), ni, time_offset, current_time, field_filter, fixed_numeric_width))
                for f, t in zip(val.__slots__, val._slot_types) if f in fields])
        else:  # Python2
            vals = '\n'.join([
                p % (f, strify_message(_convert_getattr(val, f, t), ni, time_offset, current_time, field_filter, fixed_numeric_width))
                for f, t in itertools.izip(val.__slots__, val._slot_types) if f in fields])
        if indent:
            return '\n'+vals
        else:
            return vals

    else:
        return str(val)  # punt


def _convert_getattr(val, f, t):
    """
    Convert attribute types on the fly, if necessary.

    This is mainly to convert uint8[] fields back to an array type.
    """
    attr = getattr(val, f)
    if isstring(attr) and 'uint8[' in t:
        return [ord(x) for x in attr]
    elif isinstance(attr, bytes) and 'uint8[' in t:
        return list(attr)
    else:
        return attr


# check_type mildly violates some abstraction boundaries between .msg
# representation and the python Message representation. The
# alternative is to have the message generator map .msg types to
# python types beforehand, but that would make it harder to do
# width/signed checks.

_widths = {
    'byte': 8, 'char': 8, 'int8': 8, 'uint8': 8,
    'int16': 16, 'uint16': 16,
    'int32': 32, 'uint32': 32,
    'int64': 64, 'uint64': 64,
}


class Message(object):
    """Base class of Message data classes auto-generated from msg files."""

    # slots is explicitly both for data representation and
    # performance. Higher-level code assumes that there is a 1-to-1
    # mapping between __slots__ and message fields. In terms of
    # performance, explicitly settings slots eliminates dictionary for
    # new-style object.
    __slots__ = ['_connection_header']

    def __init__(self, *args, **kwds):
        """
        Create a new Message instance.

        There are multiple ways of initializing Message instances, either using
        a 1-to-1 correspondence between constructor arguments and message
        fields (*args), or using Python "keyword" arguments (**kwds) to
        initialize named field and leave the rest with default values.
        """
        if args and kwds:
            raise TypeError('Message constructor may only use args OR keywords, not both')
        if args:
            if len(args) != len(self.__slots__):
                raise TypeError('Invalid number of arguments, args should be %s' % str(self.__slots__) + ' args are' + str(args))
            for i, k in enumerate(self.__slots__):
                setattr(self, k, args[i])
        else:
            # validate kwds
            for k, v in kwds.items():
                if k not in self.__slots__:
                    raise AttributeError('%s is not an attribute of %s' % (k, self.__class__.__name__))
            # iterate through slots so all fields are initialized.
            # this is important so that subclasses don't reference an
            # uninitialized field and raise an AttributeError.
            for k in self.__slots__:
                if k in kwds:
                    setattr(self, k, kwds[k])
                else:
                    setattr(self, k, None)

    def __getstate__(self):
        """Support for Python pickling."""
        return [getattr(self, x) for x in self.__slots__]

    def __setstate__(self, state):
        """Support for Python pickling."""
        for x, val in zip(self.__slots__, state):
            setattr(self, x, val)

    def _get_types(self):
        raise Exception('must be overriden')

    def serialize(self, buff):
        """
        Serialize data into buffer.

        :param buff: buffer, ``StringIO``
        """
        pass

    def deserialize(self, str_):
        """
        Deserialize data in str into this instance.

        :param str_: serialized data, ``str``
        """
        pass

    def __repr__(self):
        return strify_message(self)

    def __str__(self):
        return strify_message(self)

    # TODO: unit test
    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for f in self.__slots__:
            try:
                v1 = getattr(self, f)
                v2 = getattr(other, f)
                if type(v1) in (list, tuple) and type(v2) in (list, tuple):
                    # we treat tuples and lists as equivalent
                    if tuple(v1) != tuple(v2):
                        return False
                elif not v1 == v2:
                    return False
            except AttributeError:
                return False
        return True

    def __ne__(self, other):
        return not self == other
